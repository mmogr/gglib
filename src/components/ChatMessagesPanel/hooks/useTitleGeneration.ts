import { useState, useEffect, useRef, useCallback } from 'react';
import type { ThreadRuntime } from '@assistant-ui/react';
import { getMessages, generateChatTitle } from '../../../services/clients/chat';
import type { ConversationSummary } from '../../../services/clients/chat';
import type { ToastType } from '../../Toast';

/**
 * Options for the useTitleGeneration hook.
 */
export interface UseTitleGenerationOptions {
  /** The thread runtime from @assistant-ui/react */
  threadRuntime: ThreadRuntime | null;
  /** Currently active conversation */
  activeConversation: ConversationSummary | null;
  /** Currently active conversation ID */
  activeConversationId: number | null;
  /** Server port for AI title generation */
  serverPort: number;
  /** Prompt template for title generation */
  titleGenerationPrompt: string;
  /** Callback to rename conversation */
  onRenameConversation: (title: string) => Promise<void>;
  /** Toast notification function */
  showToast: (message: string, type?: ToastType, duration?: number) => void;
}

/**
 * Result returned by useTitleGeneration.
 */
export interface UseTitleGenerationResult {
  /** Current title draft (for editing) */
  titleDraft: string;
  /** Update title draft */
  setTitleDraft: (title: string) => void;
  /** Whether rename input is visible */
  isRenaming: boolean;
  /** Start rename mode */
  startRenaming: () => void;
  /** Cancel rename mode */
  cancelRenaming: () => void;
  /** Commit the rename */
  commitRename: () => Promise<void>;
  /** Whether AI title generation is in progress */
  isGeneratingTitle: boolean;
  /** Trigger AI title generation */
  generateTitle: (skipConfirmation?: boolean) => Promise<void>;
}

/**
 * Hook for managing conversation title editing and AI generation.
 * 
 * Responsibilities:
 * - Manages title draft state for inline editing
 * - Handles rename commit/cancel
 * - Auto-generates title on first assistant response
 * - Manual AI title generation with confirmation
 */
export function useTitleGeneration({
  threadRuntime,
  activeConversation,
  activeConversationId,
  serverPort,
  titleGenerationPrompt,
  onRenameConversation,
  showToast,
}: UseTitleGenerationOptions): UseTitleGenerationResult {
  const [titleDraft, setTitleDraft] = useState('');
  const [isRenaming, setIsRenaming] = useState(false);
  const [isGeneratingTitle, setIsGeneratingTitle] = useState(false);
  const hasAutoGeneratedTitleRef = useRef(false);

  // Sync title draft with active conversation
  useEffect(() => {
    if (activeConversation && !isRenaming) {
      setTitleDraft(activeConversation.title);
    }
  }, [activeConversation, isRenaming]);

  // Reset state when conversation changes
  useEffect(() => {
    setIsGeneratingTitle(false);
    hasAutoGeneratedTitleRef.current = false;
  }, [activeConversationId]);

  const startRenaming = useCallback(() => {
    setIsRenaming(true);
  }, []);

  const cancelRenaming = useCallback(() => {
    setIsRenaming(false);
    setTitleDraft(activeConversation?.title ?? '');
  }, [activeConversation?.title]);

  const commitRename = useCallback(async () => {
    if (!titleDraft.trim()) {
      setIsRenaming(false);
      setTitleDraft(activeConversation?.title ?? '');
      return;
    }
    await onRenameConversation(titleDraft.trim());
    setIsRenaming(false);
  }, [titleDraft, activeConversation?.title, onRenameConversation]);

  // Generate chat title using AI
  const generateTitle = useCallback(async (skipConfirmation = false) => {
    // Early return if no active conversation ID - prevents errors during state transitions
    if (!activeConversationId) {
      showToast('No active conversation', 'warning');
      return;
    }

    if (!activeConversation || !serverPort) return;

    // Show confirmation if overwriting an existing non-default title
    const isDefaultTitle = activeConversation.title === 'New Chat' || !activeConversation.title;
    if (!skipConfirmation && !isDefaultTitle) {
      const confirmed = window.confirm('Replace current title with AI-generated one?');
      if (!confirmed) return;
    }

    setIsGeneratingTitle(true);
    try {
      // Fetch fresh messages from the database
      const messages = await getMessages(activeConversationId);
      
      if (messages.length === 0) {
        showToast('Cannot generate title for empty conversation', 'warning');
        return;
      }

      const generatedTitle = await generateChatTitle(
        serverPort,
        messages,
        titleGenerationPrompt,
      );

      await onRenameConversation(generatedTitle);
      showToast('Title generated successfully', 'success');
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Failed to generate title';
      showToast(message, 'error');
      console.error('Title generation failed:', error);
    } finally {
      setIsGeneratingTitle(false);
    }
  }, [activeConversation, activeConversationId, serverPort, titleGenerationPrompt, onRenameConversation, showToast]);

  // Auto-generate title on first assistant response
  useEffect(() => {
    if (!threadRuntime || !activeConversation || !activeConversationId || !serverPort) return;
    if (hasAutoGeneratedTitleRef.current) return;

    // Only auto-generate if title is still the default
    const isDefaultTitle = activeConversation.title === 'New Chat' || !activeConversation.title;
    if (!isDefaultTitle) {
      hasAutoGeneratedTitleRef.current = true; // Don't try again for this conversation
      return;
    }

    const unsubscribe = threadRuntime.subscribe(() => {
      const state = threadRuntime.getState();
      
      // Check if we have at least one completed assistant message
      const hasCompletedAssistantMessage = state.messages.some(
        (msg) => msg.role === 'assistant' && msg.status?.type === 'complete'
      );

      // Also need at least one user message for context
      const hasUserMessage = state.messages.some((msg) => msg.role === 'user');

      if (hasCompletedAssistantMessage && hasUserMessage && !hasAutoGeneratedTitleRef.current) {
        hasAutoGeneratedTitleRef.current = true;
        
        // Capture the current conversation ID to avoid stale closure issues
        const conversationIdAtTrigger = activeConversationId;
        
        // Delay slightly to ensure message is persisted first
        setTimeout(() => {
          // Re-check that the conversation is still active before generating
          if (conversationIdAtTrigger && conversationIdAtTrigger === activeConversationId) {
            generateTitle(true); // Skip confirmation for auto-generate
          }
        }, 500);
      }
    });

    return unsubscribe;
  }, [threadRuntime, activeConversation, activeConversationId, serverPort, generateTitle]);

  return {
    titleDraft,
    setTitleDraft,
    isRenaming,
    startRenaming,
    cancelRenaming,
    commitRename,
    isGeneratingTitle,
    generateTitle,
  };
}
