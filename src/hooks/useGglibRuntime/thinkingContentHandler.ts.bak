/**
 * Thinking content handler for streaming chat responses.
 *
 * Manages reasoning/thinking phases from reasoning models as proper message parts.
 * Returns arrays of message parts (reasoning and text) instead of embedding thinking
 * in strings. This allows assistant-ui to render reasoning blocks with the Reasoning
 * component, which provides collapsible UI and proper grouping.
 *
 * Handles both:
 * - `reasoning_content` field from the SSE delta (DeepSeek R1 native format)
 * - Inline `<think>...</think>` tags in content (parsed during streaming)
 *
 * Multiple reasoning blocks are preserved across agentic loop iterations.
 *
 * @module useThinkingContent
 */

import {
  parseStreamingThinkingContent,
} from '../../utils/thinkingParser';

// =============================================================================
// Types
// =============================================================================

/** Message part types for assistant-ui */
export type MessagePart =
  | { type: 'reasoning'; text: string }
  | { type: 'text'; text: string };

/** Current reasoning block being accumulated */
interface ReasoningBlock {
  text: string;
  startedAt: number;
}

/** Thinking content handler interface */
export interface ThinkingContentHandler {
  /**
   * Handle a reasoning_content delta from SSE stream.
   * @param content - The reasoning content delta
   */
  handleReasoningDelta(content: string): void;

  /**
   * Handle main content delta that may contain inline <think> tags.
   * @param content - The main content delta
   * @param accumulated - The total accumulated main content so far
   */
  handleContentDelta(content: string, accumulated: string): void;

  /**
   * Signal that main (non-thinking) content has started.
   * Used to finalize the current reasoning block.
   */
  markMainContentStarted(): void;

  /**
   * Get all message parts accumulated so far.
   * Returns array of reasoning and text parts in order.
   */
  getMessageParts(): MessagePart[];

  /**
   * Check if currently accumulating reasoning content.
   */
  isThinking(): boolean;

  /**
   * Get the current thinking block if complete.
   * @returns The thinking block with duration, or null if not complete
   */
  getCompletedBlock(): ThinkingBlock | null;

  /**
   * Reset the handler to initial state.
   */
  reset(): void;
}

// =============================================================================
// Factory
// =============================================================================

/**
 * Create a new thinking content handler.
 *
 * Manages two sources of thinking content:
 * 1. `reasoning_content` SSE delta field (from models like DeepSeek R1)
 * 2. Inline `<think>...</think>` tags in the main content
 *
 * In agentic loops, thinking blocks from previous iterations can be passed
 * to buildDisplayContent() and buildFinalContent() to preserve all reasoning.
 *
 * @returns A new ThinkingContentHandler instance
 *
 * @example
 * ```ts
 * const previousBlocks: ThinkingBlock[] = [];
 * const thinkingHandler = createThinkingContentHandler();
 *
 * for await (const delta of parseSSEStream(reader)) {
 *   if (delta.reasoningContent) {
 *     thinkingHandler.handleReasoningDelta(delta.reasoningContent);
 *   }
 *   if (delta.content) {
 *     mainContent += delta.content;
 *     thinkingHandler.handleContentDelta(delta.content, mainContent);
 *     if (!hasReceivedMainContent && thinkingHandler.getState().thinkingContent) {
 *       thinkingHandler.markMainContentStarted();
 *       hasReceivedMainContent = true;
 *     }
 *   }
 *
 *   const displayContent = thinkingHandler.buildDisplayContent(mainContent, previousBlocks);
 *   yield { content: [{ type: 'text', text: displayContent }] };
 * }
 *
 * const finalContent = thinkingHandler.buildFinalContent(mainContent, previousBlocks);
 * const block = thinkingHandler.getCompletedBlock();
 * if (block) previousBlocks.push(block);
 * ```
 */
export function createThinkingContentHandler(): ThinkingContentHandler {
  // State for reasoning_content field
  let thinkingContent = '';
  let thinkingStartedAt: number | null = null;
  let thinkingEndedAt: number | null = null;

  // State for inline <think> tags
  let inlineStartedAt: number | null = null;
  let inlineEndedAt: number | null = null;

  function handleReasoningDelta(content: string): void {
    if (!thinkingStartedAt) {
      thinkingStartedAt = Date.now();
    }
    thinkingContent += content;
  }

  function handleContentDelta(_content: string, accumulated: string): void {
    // Check for inline thinking in accumulated content
    const parsed = parseStreamingThinkingContent(accumulated);
    if (parsed.thinking && inlineStartedAt === null) {
      inlineStartedAt = Date.now();
    }
    if (parsed.isThinkingComplete && inlineEndedAt === null && parsed.thinking) {
      inlineEndedAt = Date.now();
    }
  }

  function markMainContentStarted(): void {
    if (thinkingContent && !thinkingEndedAt) {
      thinkingEndedAt = Date.now();
    }
  }

  function buildDisplayContent(mainContent: string): string {
    // Case 1: We have reasoning_content from the SSE delta
    if (thinkingContent) {
      const currentEndTime = thinkingEndedAt ?? Date.now();
      const durationSeconds = (currentEndTime - (thinkingStartedAt ?? currentEndTime)) / 1000;
      return embedThinkingContent(thinkingContent, mainContent, durationSeconds);
    }

    // Case 2: Check for inline <think> tags in main content
    const parsed = parseStreamingThinkingContent(mainContent);
    if (parsed.thinking) {
      const startTime = inlineStartedAt ?? Date.now();
      const currentEndTime = inlineEndedAt ?? Date.now();
      const durationSeconds = (currentEndTime - startTime) / 1000;
      return embedThinkingContent(parsed.thinking, parsed.content, durationSeconds);
    }

    // Case 3: No thinking content
    return mainContent;
  }

  function buildFinalContent(mainContent: string): string {
    // Case 1: We have reasoning_content
    if (thinkingContent) {
      const endTime = thinkingEndedAt ?? Date.now();
      const durationSeconds = (endTime - (thinkingStartedAt ?? endTime)) / 1000;
      return embedThinkingContent(thinkingContent, mainContent, durationSeconds);
    }

    // Case 2: Inline <think> tags
    if (inlineStartedAt !== null) {
      const parsed = parseStreamingThinkingContent(mainContent);
      if (parsed.thinking) {
        const endTime = inlineEndedAt ?? Date.now();
        const durationSeconds = (endTime - inlineStartedAt) / 1000;
        return embedThinkingContent(parsed.thinking, parsed.content, durationSeconds);
      }
    }

    // Case 3: No thinking
    return mainContent;
  }

  function getState(): ThinkingState {
    return {
      isThinking: thinkingContent.length > 0 && thinkingEndedAt === null,
      thinkingContent,
      startedAt: thinkingStartedAt,
      endedAt: thinkingEndedAt,
    };
  }

  function reset(): void {
    thinkingContent = '';
    thinkingStartedAt = null;
    thinkingEndedAt = null;
    inlineStartedAt = null;
    inlineEndedAt = null;
  }

  return {
    handleReasoningDelta,
    handleContentDelta,
    markMainContentStarted,
    buildDisplayContent,
    buildFinalContent,
    getState,
    reset,
  };
}
