name: Update Badges

on:
  workflow_run:
    workflows: ["CI", "Coverage", "Release"]
    types: [completed]
    branches: [main]

permissions:
  contents: write
  actions: read

# Prevent race conditions when updating the badges branch
concurrency:
  group: badges-${{ github.event.workflow_run.name }}
  cancel-in-progress: false

jobs:
  # =============================================================================
  # CI WORKFLOW: Update test badges and boundary badge
  # =============================================================================
  update-test-badges:
    name: Update Test Badges
    if: ${{ github.event.workflow_run.name == 'CI' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout badges branch
        uses: actions/checkout@v4
        with:
          ref: badges
          fetch-depth: 1

      - name: Download CI test artifacts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          rm -rf artifacts
          mkdir -p artifacts badges
          
          echo "Downloading test-results from CI run ${{ github.event.workflow_run.id }}"
          gh run download "${{ github.event.workflow_run.id }}" \
            --name test-results \
            --dir artifacts || echo "No test-results artifact found"
          
          echo "Downloaded files:"
          find artifacts -type f 2>/dev/null || echo "No files"

      - name: Generate test badge JSON
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          CONCLUSION="${{ github.event.workflow_run.conclusion }}"
          
          # --- Aggregate Rust tests ---
          RUST_TEST_FILE="$(find artifacts -name 'rust-test-output.txt' -type f 2>/dev/null | head -1)"
          if [ -n "$RUST_TEST_FILE" ] && [ -f "$RUST_TEST_FILE" ]; then
            echo "Parsing Rust test results from: $RUST_TEST_FILE"
            PASSED=$(grep -o "test result: ok\. [0-9]* passed" "$RUST_TEST_FILE" | grep -o "[0-9]*" | awk '{s+=$1} END {print s+0}')
            FAILED=$(grep -o "[0-9]* failed" "$RUST_TEST_FILE" | grep -o "[0-9]*" | awk '{s+=$1} END {print s+0}')
            TOTAL=$((PASSED + FAILED))
            
            if [ "$TOTAL" -gt 0 ]; then
              PCT=$((PASSED * 100 / TOTAL))
              MSG="${PASSED}/${TOTAL} (${PCT}%)"
              if [ "$PCT" -eq 100 ]; then COL="brightgreen";
              elif [ "$PCT" -gt 90 ]; then COL="green";
              elif [ "$PCT" -gt 80 ]; then COL="yellowgreen";
              elif [ "$PCT" -gt 60 ]; then COL="yellow";
              else COL="red"; fi
            else
              MSG="0/0"
              COL="yellow"
            fi
            
            echo "{\"schemaVersion\":1,\"label\":\"Rust tests\",\"message\":\"$MSG\",\"color\":\"$COL\"}" > badges/tests.json
            echo "Rust tests: $MSG"
          elif [ "$CONCLUSION" == "failure" ]; then
            echo '{"schemaVersion":1,"label":"Rust tests","message":"failed","color":"red"}' > badges/tests.json
          fi
          
          # --- Per-crate Rust tests ---
          for CRATE in gglib-core gglib-db gglib-gguf gglib-hf gglib-download gglib-mcp gglib-proxy gglib-runtime gglib-gui gglib-cli gglib-axum gglib-tauri; do
            FILE="$(find artifacts -name "rust-test-$CRATE.txt" -type f 2>/dev/null | head -1)"
            if [ -n "$FILE" ] && [ -f "$FILE" ]; then
              echo "Parsing $CRATE test results"
              P=$(grep -o "test result: ok\. [0-9]* passed" "$FILE" | grep -o "[0-9]*" | awk '{s+=$1} END {print s+0}')
              F=$(grep -o "[0-9]* failed" "$FILE" | grep -o "[0-9]*" | awk '{s+=$1} END {print s+0}')
              T=$((P + F))
              
              if [ "$T" -gt 0 ]; then
                PCT=$((P * 100 / T))
                MSG="${P}/${T}"
                if [ "$PCT" -eq 100 ]; then COL="brightgreen";
                elif [ "$PCT" -gt 90 ]; then COL="green";
                elif [ "$PCT" -gt 80 ]; then COL="yellowgreen";
                elif [ "$PCT" -gt 60 ]; then COL="yellow";
                else COL="red"; fi
              else
                MSG="0/0"
                COL="yellow"
              fi
              
              echo "{\"schemaVersion\":1,\"label\":\"$CRATE\",\"message\":\"$MSG\",\"color\":\"$COL\"}" > "badges/$CRATE-tests.json"
              echo "$CRATE: $MSG"
            fi
          done
          
          # =============================================================================
          # Per-module test badges (parsed from per-crate test output)
          # =============================================================================
          
          # Helper function to extract module test counts from crate test output
          # Test names in Rust follow pattern: module::submodule::tests::test_name
          extract_module_tests() {
            local TEST_FILE=$1
            local MODULE=$2
            local BADGE_NAME=$3
            
            if [ -f "$TEST_FILE" ]; then
              # Count tests that start with the module name (e.g., "domain::" or "handlers::")
              # Look for lines like "test domain::model::tests::..." and count ok/FAILED
              PASSED=$(grep -E "^test ${MODULE}::" "$TEST_FILE" | grep -c " \.\.\. ok$" || echo "0")
              FAILED=$(grep -E "^test ${MODULE}::" "$TEST_FILE" | grep -c " \.\.\. FAILED$" || echo "0")
              TOTAL=$((PASSED + FAILED))
              
              if [ "$TOTAL" -gt 0 ]; then
                PCT=$((PASSED * 100 / TOTAL))
                MSG="${PASSED}/${TOTAL}"
                if [ "$PCT" -eq 100 ]; then COL="brightgreen";
                elif [ "$PCT" -gt 90 ]; then COL="green";
                elif [ "$PCT" -gt 80 ]; then COL="yellowgreen";
                elif [ "$PCT" -gt 60 ]; then COL="yellow";
                else COL="red"; fi
                echo "{\"schemaVersion\":1,\"label\":\"tests\",\"message\":\"$MSG\",\"color\":\"$COL\"}" > "badges/$BADGE_NAME-tests.json"
                echo "  $BADGE_NAME: $MSG"
              else
                # No tests found for this module - generate a "0" badge
                echo "{\"schemaVersion\":1,\"label\":\"tests\",\"message\":\"0\",\"color\":\"lightgrey\"}" > "badges/$BADGE_NAME-tests.json"
                echo "  $BADGE_NAME: 0 (no tests)"
              fi
            fi
          }
          
          # gglib-core modules
          CORE_TEST="$(find artifacts -name 'rust-test-gglib-core.txt' -type f 2>/dev/null | head -1)"
          for MODULE in domain ports services events paths download utils; do
            extract_module_tests "$CORE_TEST" "$MODULE" "gglib-core-$MODULE"
          done
          
          # gglib-db modules
          DB_TEST="$(find artifacts -name 'rust-test-gglib-db.txt' -type f 2>/dev/null | head -1)"
          extract_module_tests "$DB_TEST" "repositories" "gglib-db-repositories"
          
          # gglib-gguf modules
          GGUF_TEST="$(find artifacts -name 'rust-test-gglib-gguf.txt' -type f 2>/dev/null | head -1)"
          extract_module_tests "$GGUF_TEST" "capabilities" "gglib-gguf-capabilities"
          
          # gglib-download modules
          DL_TEST="$(find artifacts -name 'rust-test-gglib-download.txt' -type f 2>/dev/null | head -1)"
          for MODULE in queue executor progress resolver cli_exec; do
            extract_module_tests "$DL_TEST" "$MODULE" "gglib-download-$MODULE"
          done
          
          # gglib-runtime modules
          RT_TEST="$(find artifacts -name 'rust-test-gglib-runtime.txt' -type f 2>/dev/null | head -1)"
          for MODULE in llama proxy process system assistant_ui ports_impl; do
            extract_module_tests "$RT_TEST" "$MODULE" "gglib-runtime-$MODULE"
          done
          
          # gglib-cli modules
          CLI_TEST="$(find artifacts -name 'rust-test-gglib-cli.txt' -type f 2>/dev/null | head -1)"
          for MODULE in handlers presentation utils; do
            extract_module_tests "$CLI_TEST" "$MODULE" "gglib-cli-$MODULE"
          done
          
          # gglib-cli submodules (handlers subdirectories)
          if [ -f "$CLI_TEST" ]; then
            # handlers/download/* tests
            PASSED=$(grep -E "^test handlers::download::" "$CLI_TEST" | grep -c " \.\.\. ok$" || echo "0")
            FAILED=$(grep -E "^test handlers::download::" "$CLI_TEST" | grep -c " \.\.\. FAILED$" || echo "0")
            TOTAL=$((PASSED + FAILED))
            if [ "$TOTAL" -gt 0 ]; then
              PCT=$((PASSED * 100 / TOTAL))
              MSG="${PASSED}/${TOTAL}"
              if [ "$PCT" -eq 100 ]; then COL="brightgreen";
              elif [ "$PCT" -gt 90 ]; then COL="green";
              elif [ "$PCT" -gt 80 ]; then COL="yellowgreen";
              elif [ "$PCT" -gt 60 ]; then COL="yellow";
              else COL="red"; fi
              echo "{\"schemaVersion\":1,\"label\":\"tests\",\"message\":\"$MSG\",\"color\":\"$COL\"}" > "badges/gglib-cli-download-tests.json"
              echo "  gglib-cli-download: $MSG"
            else
              echo "{\"schemaVersion\":1,\"label\":\"tests\",\"message\":\"0\",\"color\":\"lightgrey\"}" > "badges/gglib-cli-download-tests.json"
            fi
            
            # handlers/check_deps/* tests
            PASSED=$(grep -E "^test handlers::check_deps::" "$CLI_TEST" | grep -c " \.\.\. ok$" || echo "0")
            FAILED=$(grep -E "^test handlers::check_deps::" "$CLI_TEST" | grep -c " \.\.\. FAILED$" || echo "0")
            TOTAL=$((PASSED + FAILED))
            if [ "$TOTAL" -gt 0 ]; then
              PCT=$((PASSED * 100 / TOTAL))
              MSG="${PASSED}/${TOTAL}"
              if [ "$PCT" -eq 100 ]; then COL="brightgreen";
              elif [ "$PCT" -gt 90 ]; then COL="green";
              elif [ "$PCT" -gt 80 ]; then COL="yellowgreen";
              elif [ "$PCT" -gt 60 ]; then COL="yellow";
              else COL="red"; fi
              echo "{\"schemaVersion\":1,\"label\":\"tests\",\"message\":\"$MSG\",\"color\":\"$COL\"}" > "badges/gglib-cli-check_deps-tests.json"
              echo "  gglib-cli-check_deps: $MSG"
            else
              echo "{\"schemaVersion\":1,\"label\":\"tests\",\"message\":\"0\",\"color\":\"lightgrey\"}" > "badges/gglib-cli-check_deps-tests.json"
            fi
            
            # handlers/check_deps/instructions/* tests
            PASSED=$(grep -E "^test handlers::check_deps::instructions::" "$CLI_TEST" | grep -c " \.\.\. ok$" || echo "0")
            FAILED=$(grep -E "^test handlers::check_deps::instructions::" "$CLI_TEST" | grep -c " \.\.\. FAILED$" || echo "0")
            TOTAL=$((PASSED + FAILED))
            if [ "$TOTAL" -gt 0 ]; then
              PCT=$((PASSED * 100 / TOTAL))
              MSG="${PASSED}/${TOTAL}"
              if [ "$PCT" -eq 100 ]; then COL="brightgreen";
              elif [ "$PCT" -gt 90 ]; then COL="green";
              elif [ "$PCT" -gt 80 ]; then COL="yellowgreen";
              elif [ "$PCT" -gt 60 ]; then COL="yellow";
              else COL="red"; fi
              echo "{\"schemaVersion\":1,\"label\":\"tests\",\"message\":\"$MSG\",\"color\":\"$COL\"}" > "badges/gglib-cli-instructions-tests.json"
              echo "  gglib-cli-instructions: $MSG"
            else
              echo "{\"schemaVersion\":1,\"label\":\"tests\",\"message\":\"0\",\"color\":\"lightgrey\"}" > "badges/gglib-cli-instructions-tests.json"
            fi
          fi
          
          # gglib-axum modules
          AXUM_TEST="$(find artifacts -name 'rust-test-gglib-axum.txt' -type f 2>/dev/null | head -1)"
          extract_module_tests "$AXUM_TEST" "dto" "gglib-axum-dto"
          
          # gglib-tauri modules
          TAURI_TEST="$(find artifacts -name 'rust-test-gglib-tauri.txt' -type f 2>/dev/null | head -1)"
          extract_module_tests "$TAURI_TEST" "gui_backend" "gglib-tauri-gui_backend"
          
          # gglib-hf modules
          HF_TEST="$(find artifacts -name 'rust-test-gglib-hf.txt' -type f 2>/dev/null | head -1)"
          extract_module_tests "$HF_TEST" "client" "gglib-hf-client"
          
          # gglib-proxy modules
          PROXY_TEST="$(find artifacts -name 'rust-test-gglib-proxy.txt' -type f 2>/dev/null | head -1)"
          for MODULE in server models forward; do
            extract_module_tests "$PROXY_TEST" "$MODULE" "gglib-proxy-$MODULE"
          done
          
          # gglib-mcp modules  
          MCP_TEST="$(find artifacts -name 'rust-test-gglib-mcp.txt' -type f 2>/dev/null | head -1)"
          for MODULE in client manager service path resolver; do
            extract_module_tests "$MCP_TEST" "$MODULE" "gglib-mcp-$MODULE"
          done
          
          # gglib-gui modules
          GUI_TEST="$(find artifacts -name 'rust-test-gglib-gui.txt' -type f 2>/dev/null | head -1)"
          for MODULE in backend deps error downloads models servers settings mcp proxy types; do
            extract_module_tests "$GUI_TEST" "$MODULE" "gglib-gui-$MODULE"
          done
          
          # --- Boundary badge ---
          # Download boundary results from separate artifact
          set +e
          gh run download ${{ github.event.workflow_run.id }} -n boundary-results -D artifacts/boundary
          boundary_rc=$?
          set -e
          if [ $boundary_rc -ne 0 ]; then
            echo "WARNING: boundary-results artifact download failed (rc=$boundary_rc)"
            echo '{"schemaVersion":1,"label":"boundaries","message":"unknown","color":"lightgrey"}' > badges/boundary.json
          fi
          BOUNDARY_FILE="$(find artifacts -name 'boundary-status.json' -type f 2>/dev/null | head -1)"
          if [ -n "$BOUNDARY_FILE" ] && [ -f "$BOUNDARY_FILE" ]; then
            echo "Parsing boundary check results"
            OVERALL=$(jq -r '.overall // "unknown"' "$BOUNDARY_FILE" 2>/dev/null || echo "unknown")
            if [ "$OVERALL" == "pass" ]; then
              MSG="✓ clean"
              COL="brightgreen"
            elif [ "$OVERALL" == "fail" ]; then
              MSG="✗ violation"
              COL="red"
            else
              MSG="unknown"
              COL="lightgrey"
            fi
            echo "{\"schemaVersion\":1,\"label\":\"boundaries\",\"message\":\"$MSG\",\"color\":\"$COL\"}" > badges/boundary.json
            echo "Boundary: $MSG"
          elif [ "$CONCLUSION" == "failure" ]; then
            echo '{"schemaVersion":1,"label":"boundaries","message":"failed","color":"red"}' > badges/boundary.json
          fi
          
          # --- TypeScript tests (from CI artifacts) ---
          TS_JSON="$(find artifacts -name 'ts-test-results.json' -type f 2>/dev/null | head -1)"
          TS_TEXT="$(find artifacts -name 'ts-test-output.txt' -type f 2>/dev/null | head -1)"
          
          if [ -n "$TS_JSON" ] && [ -f "$TS_JSON" ]; then
            echo "Parsing TS test results from JSON"
            TS_PASSED=$(jq -r '.numPassedTests // 0' "$TS_JSON" 2>/dev/null || echo "0")
            TS_FAILED=$(jq -r '.numFailedTests // 0' "$TS_JSON" 2>/dev/null || echo "0")
            TS_TOTAL=$(jq -r '.numTotalTests // 0' "$TS_JSON" 2>/dev/null || echo "0")
          elif [ -n "$TS_TEXT" ] && [ -f "$TS_TEXT" ]; then
            echo "Parsing TS test results from text"
            TS_PASSED=$(grep -E "Tests\s+[0-9]+ passed" "$TS_TEXT" | grep -oE "[0-9]+ passed" | grep -oE "[0-9]+" | tail -1 || echo "0")
            TS_FAILED=$(grep -E "[0-9]+ failed" "$TS_TEXT" | grep -oE "[0-9]+ failed" | grep -oE "[0-9]+" | tail -1 || echo "0")
            TS_TOTAL=$((TS_PASSED + TS_FAILED))
          else
            TS_PASSED=0
            TS_FAILED=0
            TS_TOTAL=0
          fi
          
          TS_PASSED=${TS_PASSED:-0}
          TS_FAILED=${TS_FAILED:-0}
          TS_TOTAL=${TS_TOTAL:-0}
          
          if [ "$TS_TOTAL" -gt 0 ]; then
            TS_PCT=$((TS_PASSED * 100 / TS_TOTAL))
            TS_MSG="${TS_PASSED}/${TS_TOTAL} (${TS_PCT}%)"
            if [ "$TS_PCT" -eq 100 ]; then TS_COL="brightgreen";
            elif [ "$TS_PCT" -gt 90 ]; then TS_COL="green";
            elif [ "$TS_PCT" -gt 80 ]; then TS_COL="yellowgreen";
            elif [ "$TS_PCT" -gt 60 ]; then TS_COL="yellow";
            else TS_COL="red"; fi
            
            echo "{\"schemaVersion\":1,\"label\":\"TS tests\",\"message\":\"$TS_MSG\",\"color\":\"$TS_COL\"}" > badges/ts-tests.json
            echo "TS tests: $TS_MSG"
          fi
          
          echo "Generated test badges:"
          ls -la badges/

      - name: Deploy to badges branch
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./badges
          publish_branch: badges
          keep_files: true
          user_name: 'github-actions[bot]'
          user_email: 'github-actions[bot]@users.noreply.github.com'
          commit_message: 'Update test badges [skip ci] ${{ github.event.workflow_run.head_sha }}'

  # =============================================================================
  # COVERAGE WORKFLOW: Update coverage badges only
  # =============================================================================
  update-coverage-badges:
    name: Update Coverage Badges
    if: ${{ github.event.workflow_run.name == 'Coverage' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout badges branch
        uses: actions/checkout@v4
        with:
          ref: badges
          fetch-depth: 1

      - name: Download Coverage artifacts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          rm -rf artifacts
          mkdir -p artifacts badges
          
          echo "Downloading coverage-report from Coverage run ${{ github.event.workflow_run.id }}"
          gh run download "${{ github.event.workflow_run.id }}" \
            --name coverage-report \
            --dir artifacts || echo "No coverage-report artifact found"
          
          echo "Downloaded files:"
          find artifacts -type f 2>/dev/null || echo "No files"

      - name: Generate coverage badge JSON
        run: |
          CONCLUSION="${{ github.event.workflow_run.conclusion }}"
          
          # --- Aggregate Rust coverage ---
          LCOV_FILE="$(find artifacts -name 'lcov.info' -type f 2>/dev/null | head -1)"
          if [ -n "$LCOV_FILE" ] && [ -f "$LCOV_FILE" ]; then
            echo "Parsing Rust coverage from: $LCOV_FILE"
            TOTAL_LINES=$(grep -h '^LF:' "$LCOV_FILE" | awk -F ':' '{s+=$2} END {print s+0}')
            COVERED_LINES=$(grep -h '^LH:' "$LCOV_FILE" | awk -F ':' '{s+=$2} END {print s+0}')
            
            if [ "$TOTAL_LINES" -gt 0 ]; then
              COV=$(awk -v c="$COVERED_LINES" -v t="$TOTAL_LINES" 'BEGIN { printf "%d", (c/t)*100 }')
              MSG="${COV}%"
              if [ "$COV" -gt 90 ]; then COL="brightgreen";
              elif [ "$COV" -gt 80 ]; then COL="green";
              elif [ "$COV" -gt 70 ]; then COL="yellowgreen";
              elif [ "$COV" -gt 60 ]; then COL="yellow";
              else COL="red"; fi
            else
              MSG="0%"
              COL="red"
            fi
            
            echo "{\"schemaVersion\":1,\"label\":\"Rust coverage\",\"message\":\"$MSG\",\"color\":\"$COL\"}" > badges/coverage.json
            echo "Rust coverage: $MSG"
          elif [ "$CONCLUSION" == "failure" ]; then
            echo '{"schemaVersion":1,"label":"Rust coverage","message":"failed","color":"red"}' > badges/coverage.json
          fi
          
          # --- Per-crate Rust coverage ---
          for CRATE in gglib-core gglib-db gglib-gguf gglib-hf gglib-download gglib-mcp gglib-proxy gglib-runtime gglib-gui gglib-cli gglib-axum gglib-tauri; do
            CRATE_LCOV="$(find artifacts -name "$CRATE-lcov.info" -type f 2>/dev/null | head -1)"
            if [ -n "$CRATE_LCOV" ] && [ -f "$CRATE_LCOV" ]; then
              echo "Parsing $CRATE coverage"
              TL=$(grep -h '^LF:' "$CRATE_LCOV" | awk -F ':' '{s+=$2} END {print s+0}')
              CL=$(grep -h '^LH:' "$CRATE_LCOV" | awk -F ':' '{s+=$2} END {print s+0}')
              
              if [ "$TL" -gt 0 ]; then
                COV=$(awk -v c="$CL" -v t="$TL" 'BEGIN { printf "%d", (c/t)*100 }')
                MSG="${COV}%"
                if [ "$COV" -gt 90 ]; then COL="brightgreen";
                elif [ "$COV" -gt 80 ]; then COL="green";
                elif [ "$COV" -gt 70 ]; then COL="yellowgreen";
                elif [ "$COV" -gt 60 ]; then COL="yellow";
                else COL="red"; fi
              else
                MSG="0%"
                COL="red"
              fi
              
              echo "{\"schemaVersion\":1,\"label\":\"$CRATE cov\",\"message\":\"$MSG\",\"color\":\"$COL\"}" > "badges/$CRATE-coverage.json"
              echo "$CRATE coverage: $MSG"
            fi
          done
          
          # =============================================================================
          # Per-module coverage extraction (from per-crate lcov files)
          # =============================================================================
          
          # Helper function for coverage color
          cov_color() {
            local COV=$1
            if [ "$COV" -gt 90 ]; then echo "brightgreen";
            elif [ "$COV" -gt 80 ]; then echo "green";
            elif [ "$COV" -gt 70 ]; then echo "yellowgreen";
            elif [ "$COV" -gt 60 ]; then echo "yellow";
            else echo "red"; fi
          }
          
          # Helper function to extract module coverage from lcov
          extract_module_cov() {
            local LCOV_FILE=$1
            local MODULE_PATH=$2
            local BADGE_NAME=$3
            
            if [ -f "$LCOV_FILE" ]; then
              # Extract records matching the module path
              TL=$(awk -v path="$MODULE_PATH" '
                /^SF:/ { in_module = ($0 ~ path) }
                in_module && /^LF:/ { split($0, a, ":"); total += a[2] }
                END { print total+0 }
              ' "$LCOV_FILE")
              
              CL=$(awk -v path="$MODULE_PATH" '
                /^SF:/ { in_module = ($0 ~ path) }
                in_module && /^LH:/ { split($0, a, ":"); covered += a[2] }
                END { print covered+0 }
              ' "$LCOV_FILE")
              
              if [ "$TL" -gt 0 ]; then
                COV=$(awk -v c="$CL" -v t="$TL" 'BEGIN { printf "%d", (c/t)*100 }')
                MSG="${COV}%"
                COL=$(cov_color $COV)
                echo "{\"schemaVersion\":1,\"label\":\"cov\",\"message\":\"$MSG\",\"color\":\"$COL\"}" > "badges/$BADGE_NAME-coverage.json"
                echo "  $BADGE_NAME coverage: $MSG"
              fi
            fi
          }
          
          # gglib-core modules
          CORE_LCOV="$(find artifacts -name 'gglib-core-lcov.info' -type f 2>/dev/null | head -1)"
          for MODULE in domain ports services events paths download utils; do
            extract_module_cov "$CORE_LCOV" "src/$MODULE/" "gglib-core-$MODULE"
          done
          
          # gglib-db modules
          DB_LCOV="$(find artifacts -name 'gglib-db-lcov.info' -type f 2>/dev/null | head -1)"
          extract_module_cov "$DB_LCOV" "src/repositories/" "gglib-db-repositories"
          
          # gglib-gguf modules
          GGUF_LCOV="$(find artifacts -name 'gglib-gguf-lcov.info' -type f 2>/dev/null | head -1)"
          extract_module_cov "$GGUF_LCOV" "src/capabilities/" "gglib-gguf-capabilities"
          
          # gglib-download modules
          DL_LCOV="$(find artifacts -name 'gglib-download-lcov.info' -type f 2>/dev/null | head -1)"
          for MODULE in queue executor progress resolver cli_exec; do
            extract_module_cov "$DL_LCOV" "src/$MODULE/" "gglib-download-$MODULE"
          done
          
          # gglib-runtime modules
          RT_LCOV="$(find artifacts -name 'gglib-runtime-lcov.info' -type f 2>/dev/null | head -1)"
          for MODULE in llama proxy process system assistant_ui ports_impl; do
            extract_module_cov "$RT_LCOV" "src/$MODULE/" "gglib-runtime-$MODULE"
          done
          
          # gglib-cli modules
          CLI_LCOV="$(find artifacts -name 'gglib-cli-lcov.info' -type f 2>/dev/null | head -1)"
          for MODULE in handlers presentation utils; do
            extract_module_cov "$CLI_LCOV" "src/$MODULE/" "gglib-cli-$MODULE"
          done
          
          # gglib-cli submodules (handlers subdirectories)
          extract_module_cov "$CLI_LCOV" "src/handlers/download/" "gglib-cli-download"
          extract_module_cov "$CLI_LCOV" "src/handlers/check_deps/" "gglib-cli-check_deps"
          extract_module_cov "$CLI_LCOV" "src/handlers/check_deps/instructions/" "gglib-cli-instructions"
          
          # gglib-axum modules
          AXUM_LCOV="$(find artifacts -name 'gglib-axum-lcov.info' -type f 2>/dev/null | head -1)"
          extract_module_cov "$AXUM_LCOV" "src/dto/" "gglib-axum-dto"
          
          # gglib-tauri modules
          TAURI_LCOV="$(find artifacts -name 'gglib-tauri-lcov.info' -type f 2>/dev/null | head -1)"
          extract_module_cov "$TAURI_LCOV" "src/gui_backend/" "gglib-tauri-gui_backend"
          
          # gglib-hf modules
          HF_LCOV="$(find artifacts -name 'gglib-hf-lcov.info' -type f 2>/dev/null | head -1)"
          extract_module_cov "$HF_LCOV" "src/client/" "gglib-hf-client"
          
          # gglib-proxy modules
          PROXY_LCOV="$(find artifacts -name 'gglib-proxy-lcov.info' -type f 2>/dev/null | head -1)"
          for MODULE in server models forward; do
            extract_module_cov "$PROXY_LCOV" "src/$MODULE.rs" "gglib-proxy-$MODULE"
          done
          
          # gglib-mcp modules
          MCP_LCOV="$(find artifacts -name 'gglib-mcp-lcov.info' -type f 2>/dev/null | head -1)"
          for MODULE in client manager service path; do
            extract_module_cov "$MCP_LCOV" "src/$MODULE.rs" "gglib-mcp-$MODULE"
          done
          # gglib-mcp resolver submodule (directory, not single file)
          extract_module_cov "$MCP_LCOV" "src/resolver/" "gglib-mcp-resolver"
          
          # gglib-gui modules
          GUI_LCOV="$(find artifacts -name 'gglib-gui-lcov.info' -type f 2>/dev/null | head -1)"
          for MODULE in backend deps error downloads models servers settings mcp proxy types; do
            extract_module_cov "$GUI_LCOV" "src/$MODULE.rs" "gglib-gui-$MODULE"
          done
          
          # =============================================================================
          # Per-file coverage extraction (dynamic discovery)
          # =============================================================================
          
          # Helper function to extract file-level coverage from lcov
          extract_file_cov() {
            local LCOV_FILE=$1
            local FILE_PATH=$2
            local BADGE_NAME=$3
            
            if [ -f "$LCOV_FILE" ]; then
              # Extract records matching the exact file path
              TL=$(awk -v path="$FILE_PATH" '
                /^SF:/ { in_file = (index($0, path) > 0 && $0 ~ path"$") }
                in_file && /^LF:/ { split($0, a, ":"); total += a[2] }
                END { print total+0 }
              ' "$LCOV_FILE")
              
              CL=$(awk -v path="$FILE_PATH" '
                /^SF:/ { in_file = (index($0, path) > 0 && $0 ~ path"$") }
                in_file && /^LH:/ { split($0, a, ":"); covered += a[2] }
                END { print covered+0 }
              ' "$LCOV_FILE")
              
              if [ "$TL" -gt 0 ]; then
                COV=$(awk -v c="$CL" -v t="$TL" 'BEGIN { printf "%d", (c/t)*100 }')
                MSG="${COV}%"
                COL=$(cov_color $COV)
                echo "{\"schemaVersion\":1,\"label\":\"cov\",\"message\":\"$MSG\",\"color\":\"$COL\"}" > "badges/$BADGE_NAME-coverage.json"
              fi
            fi
          }
          
          # Helper function to convert file path to badge name
          # Uses the naming convention from the hardcoded badges:
          # - 1 level (file.rs): just "file"
          # - 2 levels (subdir/file.rs): "subdir-file"
          # - 3+ levels (a/b/file.rs): just "b-file" (last 2 components)
          path_to_badge_name() {
            local FILE_PATH=$1
            # Remove src/ prefix and .rs suffix
            local CLEAN=$(echo "$FILE_PATH" | sed 's|^src/||' | sed 's|\.rs$||')
            # Count path components
            local DEPTH=$(echo "$CLEAN" | tr '/' '\n' | wc -l | tr -d ' ')
            
            if [ "$DEPTH" -le 2 ]; then
              # 1-2 levels: use full path with slashes replaced by dashes
              echo "$CLEAN" | sed 's|/|-|g'
            else
              # 3+ levels: use only last 2 components
              echo "$CLEAN" | rev | cut -d'/' -f1-2 | rev | sed 's|/|-|g'
            fi
          }
          
          echo "Generating file-level coverage badges (dynamic discovery)..."
          
          # Dynamically discover and generate file-level coverage for each crate
          for CRATE in gglib-core gglib-db gglib-gguf gglib-hf gglib-download gglib-mcp gglib-proxy gglib-runtime gglib-gui gglib-cli gglib-axum gglib-tauri; do
            LCOV_FILE="$(find artifacts -name "$CRATE-lcov.info" -type f 2>/dev/null | head -1)"
            if [ -n "$LCOV_FILE" ] && [ -f "$LCOV_FILE" ]; then
              echo "  Processing $CRATE file-level coverage..."
              
              # Extract all source files from the lcov (SF: records)
              grep "^SF:" "$LCOV_FILE" | sed 's/^SF://' | while read -r FULL_PATH; do
                # Extract relative path from src/
                if [[ "$FULL_PATH" == *"/src/"* ]]; then
                  REL_PATH=$(echo "$FULL_PATH" | sed 's|.*/src/|src/|')
                  BADGE_SUFFIX=$(path_to_badge_name "$REL_PATH")
                  BADGE_NAME="$CRATE-$BADGE_SUFFIX"
                  
                  # Skip lib.rs and mod.rs files (they're just re-exports)
                  if [[ "$REL_PATH" != "src/lib.rs" ]] && [[ "$REL_PATH" != *"/mod.rs" ]]; then
                    extract_file_cov "$LCOV_FILE" "$REL_PATH" "$BADGE_NAME"
                  fi
                fi
              done
            fi
          done
          
          echo "Generated file-level coverage badges"
          
          # Also generate 0% coverage badges for files that exist but aren't in lcov
          # This ensures all files shown in READMEs have coverage badges
          echo "Generating missing coverage badges (0% for untested files)..."
          for CRATE in gglib-core gglib-db gglib-gguf gglib-hf gglib-download gglib-mcp gglib-proxy gglib-runtime gglib-gui gglib-cli gglib-axum gglib-tauri; do
            # Check out main to scan filesystem (we're on badges branch)
            git fetch origin main --depth=1 2>/dev/null || true
            
            # List files from main branch
            git ls-tree -r --name-only origin/main "crates/$CRATE/src" 2>/dev/null | grep '\.rs$' | while read -r FULL_PATH; do
              FILENAME=$(basename "$FULL_PATH")
              
              # Skip lib.rs, mod.rs, main.rs
              if [[ "$FILENAME" != "lib.rs" ]] && [[ "$FILENAME" != "mod.rs" ]] && [[ "$FILENAME" != "main.rs" ]]; then
                REL_PATH=$(echo "$FULL_PATH" | sed "s|crates/$CRATE/||")
                BADGE_SUFFIX=$(path_to_badge_name "$REL_PATH")
                BADGE_NAME="$CRATE-$BADGE_SUFFIX"
                
                # Only create if badge doesn't already exist
                if [ ! -f "badges/$BADGE_NAME-coverage.json" ]; then
                  echo "{\"schemaVersion\":1,\"label\":\"cov\",\"message\":\"0%\",\"color\":\"red\"}" > "badges/$BADGE_NAME-coverage.json"
                fi
              fi
            done
          done
          
          echo "Generated missing coverage badges"

          # --- TypeScript coverage ---
          TS_COV_FILE="$(find artifacts -name 'coverage-summary.json' -type f 2>/dev/null | head -1)"
          if [ -n "$TS_COV_FILE" ] && [ -f "$TS_COV_FILE" ]; then
            echo "Parsing TS coverage"
            TS_COV=$(jq -r '.total.lines.pct // 0' "$TS_COV_FILE" 2>/dev/null || echo "0")
            TS_COV=$(printf "%.0f" "$TS_COV" 2>/dev/null || echo "0")
            
            if [ "$TS_COV" -gt 90 ]; then TS_COL="brightgreen";
            elif [ "$TS_COV" -gt 80 ]; then TS_COL="green";
            elif [ "$TS_COV" -gt 70 ]; then TS_COL="yellowgreen";
            elif [ "$TS_COV" -gt 60 ]; then TS_COL="yellow";
            else TS_COL="red"; fi
            
            echo "{\"schemaVersion\":1,\"label\":\"TS coverage\",\"message\":\"${TS_COV}%\",\"color\":\"$TS_COL\"}" > badges/ts-coverage.json
            echo "TS coverage: ${TS_COV}%"
          fi
          
          echo "Generated coverage badges:"
          ls -la badges/

      - name: Deploy to badges branch
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./badges
          publish_branch: badges
          keep_files: true
          user_name: 'github-actions[bot]'
          user_email: 'github-actions[bot]@users.noreply.github.com'
          commit_message: 'Update coverage badges [skip ci] ${{ github.event.workflow_run.head_sha }}'

  # =============================================================================
  # RELEASE WORKFLOW: Update version badge and SCC metrics
  # =============================================================================
  update-release-badges:
    name: Update Release Badges
    if: ${{ github.event.workflow_run.name == 'Release' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main branch (for source analysis)
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 1

      - name: Generate version badge
        run: |
          mkdir -p badges
          VERSION=$(grep '^version = ' Cargo.toml | sed -E 's/version = "(.*)"/\1/')
          echo "Detected version: $VERSION"
          
          echo "{\"schemaVersion\":1,\"label\":\"version\",\"message\":\"v$VERSION\",\"color\":\"blue\"}" > badges/version.json

      - name: Install scc
        run: |
          curl -sL https://github.com/boyter/scc/releases/download/v3.2.0/scc_Linux_x86_64.tar.gz | tar xz
          chmod +x scc
          sudo mv scc /usr/local/bin/

      - name: Generate SCC complexity badges
        run: |
          # Helper function for LOC color
          loc_color() {
            local LOC=$1
            if [ "$LOC" -lt 200 ]; then echo "brightgreen";
            elif [ "$LOC" -lt 500 ]; then echo "green";
            elif [ "$LOC" -lt 1000 ]; then echo "yellowgreen";
            elif [ "$LOC" -lt 2000 ]; then echo "yellow";
            else echo "orange"; fi
          }
          
          # Helper function for complexity color
          cx_color() {
            local CX=$1
            if [ "$CX" -lt 10 ]; then echo "brightgreen";
            elif [ "$CX" -lt 25 ]; then echo "green";
            elif [ "$CX" -lt 50 ]; then echo "yellowgreen";
            elif [ "$CX" -lt 100 ]; then echo "yellow";
            else echo "orange"; fi
          }
          
          # Generate per-crate LOC and complexity badges
          for CRATE in gglib-core gglib-db gglib-gguf gglib-hf gglib-download gglib-mcp gglib-proxy gglib-runtime gglib-gui gglib-cli gglib-axum gglib-tauri; do
            if [ -d "crates/$CRATE" ]; then
              SCC_DATA=$(scc "crates/$CRATE" --format json 2>/dev/null | jq '[.[] | select(.Name == "Rust")] | .[0] // {Code: 0, Complexity: 0}')
              LOC=$(echo "$SCC_DATA" | jq '.Code // 0')
              COMPLEXITY=$(echo "$SCC_DATA" | jq '.Complexity // 0')
              
              LOC_COL=$(loc_color $LOC)
              CX_COL=$(cx_color $COMPLEXITY)
              
              echo "{\"schemaVersion\":1,\"label\":\"loc\",\"message\":\"$LOC\",\"color\":\"$LOC_COL\"}" > "badges/$CRATE-loc.json"
              echo "{\"schemaVersion\":1,\"label\":\"complexity\",\"message\":\"$COMPLEXITY\",\"color\":\"$CX_COL\"}" > "badges/$CRATE-complexity.json"
              echo "$CRATE: $LOC loc, $COMPLEXITY complexity"
            fi
          done
          
          # =============================================================================
          # Per-module badges for gglib-core
          # =============================================================================
          for MODULE in domain ports services events paths download utils; do
            if [ -d "crates/gglib-core/src/$MODULE" ]; then
              SCC_DATA=$(scc "crates/gglib-core/src/$MODULE" --format json 2>/dev/null | jq '[.[] | select(.Name == "Rust")] | .[0] // {Code: 0, Complexity: 0}')
              LOC=$(echo "$SCC_DATA" | jq '.Code // 0')
              COMPLEXITY=$(echo "$SCC_DATA" | jq '.Complexity // 0')
              LOC_COL=$(loc_color $LOC)
              CX_COL=$(cx_color $COMPLEXITY)
              echo "{\"schemaVersion\":1,\"label\":\"loc\",\"message\":\"$LOC\",\"color\":\"$LOC_COL\"}" > "badges/gglib-core-$MODULE-loc.json"
              echo "{\"schemaVersion\":1,\"label\":\"complexity\",\"message\":\"$COMPLEXITY\",\"color\":\"$CX_COL\"}" > "badges/gglib-core-$MODULE-complexity.json"
              echo "  gglib-core/$MODULE: $LOC loc, $COMPLEXITY complexity"
            fi
          done
          
          # =============================================================================
          # Per-module badges for gglib-db
          # =============================================================================
          if [ -d "crates/gglib-db/src/repositories" ]; then
            SCC_DATA=$(scc "crates/gglib-db/src/repositories" --format json 2>/dev/null | jq '[.[] | select(.Name == "Rust")] | .[0] // {Code: 0, Complexity: 0}')
            LOC=$(echo "$SCC_DATA" | jq '.Code // 0')
            COMPLEXITY=$(echo "$SCC_DATA" | jq '.Complexity // 0')
            LOC_COL=$(loc_color $LOC)
            CX_COL=$(cx_color $COMPLEXITY)
            echo "{\"schemaVersion\":1,\"label\":\"loc\",\"message\":\"$LOC\",\"color\":\"$LOC_COL\"}" > "badges/gglib-db-repositories-loc.json"
            echo "{\"schemaVersion\":1,\"label\":\"complexity\",\"message\":\"$COMPLEXITY\",\"color\":\"$CX_COL\"}" > "badges/gglib-db-repositories-complexity.json"
            echo "  gglib-db/repositories: $LOC loc, $COMPLEXITY complexity"
          fi
          
          # =============================================================================
          # Per-module badges for gglib-gguf
          # =============================================================================
          if [ -d "crates/gglib-gguf/src/capabilities" ]; then
            SCC_DATA=$(scc "crates/gglib-gguf/src/capabilities" --format json 2>/dev/null | jq '[.[] | select(.Name == "Rust")] | .[0] // {Code: 0, Complexity: 0}')
            LOC=$(echo "$SCC_DATA" | jq '.Code // 0')
            COMPLEXITY=$(echo "$SCC_DATA" | jq '.Complexity // 0')
            LOC_COL=$(loc_color $LOC)
            CX_COL=$(cx_color $COMPLEXITY)
            echo "{\"schemaVersion\":1,\"label\":\"loc\",\"message\":\"$LOC\",\"color\":\"$LOC_COL\"}" > "badges/gglib-gguf-capabilities-loc.json"
            echo "{\"schemaVersion\":1,\"label\":\"complexity\",\"message\":\"$COMPLEXITY\",\"color\":\"$CX_COL\"}" > "badges/gglib-gguf-capabilities-complexity.json"
            echo "  gglib-gguf/capabilities: $LOC loc, $COMPLEXITY complexity"
          fi
          
          # =============================================================================
          # Per-module badges for gglib-download
          # =============================================================================
          for MODULE in queue executor progress resolver cli_exec; do
            if [ -d "crates/gglib-download/src/$MODULE" ]; then
              SCC_DATA=$(scc "crates/gglib-download/src/$MODULE" --format json 2>/dev/null | jq '[.[] | select(.Name == "Rust")] | .[0] // {Code: 0, Complexity: 0}')
              LOC=$(echo "$SCC_DATA" | jq '.Code // 0')
              COMPLEXITY=$(echo "$SCC_DATA" | jq '.Complexity // 0')
              LOC_COL=$(loc_color $LOC)
              CX_COL=$(cx_color $COMPLEXITY)
              echo "{\"schemaVersion\":1,\"label\":\"loc\",\"message\":\"$LOC\",\"color\":\"$LOC_COL\"}" > "badges/gglib-download-$MODULE-loc.json"
              echo "{\"schemaVersion\":1,\"label\":\"complexity\",\"message\":\"$COMPLEXITY\",\"color\":\"$CX_COL\"}" > "badges/gglib-download-$MODULE-complexity.json"
              echo "  gglib-download/$MODULE: $LOC loc, $COMPLEXITY complexity"
            fi
          done
          
          # =============================================================================
          # Per-module badges for gglib-runtime
          # =============================================================================
          for MODULE in llama proxy process system assistant_ui; do
            if [ -d "crates/gglib-runtime/src/$MODULE" ]; then
              SCC_DATA=$(scc "crates/gglib-runtime/src/$MODULE" --format json 2>/dev/null | jq '[.[] | select(.Name == "Rust")] | .[0] // {Code: 0, Complexity: 0}')
              LOC=$(echo "$SCC_DATA" | jq '.Code // 0')
              COMPLEXITY=$(echo "$SCC_DATA" | jq '.Complexity // 0')
              LOC_COL=$(loc_color $LOC)
              CX_COL=$(cx_color $COMPLEXITY)
              echo "{\"schemaVersion\":1,\"label\":\"loc\",\"message\":\"$LOC\",\"color\":\"$LOC_COL\"}" > "badges/gglib-runtime-$MODULE-loc.json"
              echo "{\"schemaVersion\":1,\"label\":\"complexity\",\"message\":\"$COMPLEXITY\",\"color\":\"$CX_COL\"}" > "badges/gglib-runtime-$MODULE-complexity.json"
              echo "  gglib-runtime/$MODULE: $LOC loc, $COMPLEXITY complexity"
            fi
          done
          
          # =============================================================================
          # Per-module badges for gglib-cli
          # =============================================================================
          for MODULE in handlers presentation utils; do
            if [ -d "crates/gglib-cli/src/$MODULE" ]; then
              SCC_DATA=$(scc "crates/gglib-cli/src/$MODULE" --format json 2>/dev/null | jq '[.[] | select(.Name == "Rust")] | .[0] // {Code: 0, Complexity: 0}')
              LOC=$(echo "$SCC_DATA" | jq '.Code // 0')
              COMPLEXITY=$(echo "$SCC_DATA" | jq '.Complexity // 0')
              LOC_COL=$(loc_color $LOC)
              CX_COL=$(cx_color $COMPLEXITY)
              echo "{\"schemaVersion\":1,\"label\":\"loc\",\"message\":\"$LOC\",\"color\":\"$LOC_COL\"}" > "badges/gglib-cli-$MODULE-loc.json"
              echo "{\"schemaVersion\":1,\"label\":\"complexity\",\"message\":\"$COMPLEXITY\",\"color\":\"$CX_COL\"}" > "badges/gglib-cli-$MODULE-complexity.json"
              echo "  gglib-cli/$MODULE: $LOC loc, $COMPLEXITY complexity"
            fi
          done
          
          # =============================================================================
          # Per-module badges for gglib-axum
          # =============================================================================
          if [ -d "crates/gglib-axum/src/dto" ]; then
            SCC_DATA=$(scc "crates/gglib-axum/src/dto" --format json 2>/dev/null | jq '[.[] | select(.Name == "Rust")] | .[0] // {Code: 0, Complexity: 0}')
            LOC=$(echo "$SCC_DATA" | jq '.Code // 0')
            COMPLEXITY=$(echo "$SCC_DATA" | jq '.Complexity // 0')
            LOC_COL=$(loc_color $LOC)
            CX_COL=$(cx_color $COMPLEXITY)
            echo "{\"schemaVersion\":1,\"label\":\"loc\",\"message\":\"$LOC\",\"color\":\"$LOC_COL\"}" > "badges/gglib-axum-dto-loc.json"
            echo "{\"schemaVersion\":1,\"label\":\"complexity\",\"message\":\"$COMPLEXITY\",\"color\":\"$CX_COL\"}" > "badges/gglib-axum-dto-complexity.json"
            echo "  gglib-axum/dto: $LOC loc, $COMPLEXITY complexity"
          fi
          
          # =============================================================================
          # Per-module badges for gglib-tauri
          # =============================================================================
          if [ -d "crates/gglib-tauri/src/gui_backend" ]; then
            SCC_DATA=$(scc "crates/gglib-tauri/src/gui_backend" --format json 2>/dev/null | jq '[.[] | select(.Name == "Rust")] | .[0] // {Code: 0, Complexity: 0}')
            LOC=$(echo "$SCC_DATA" | jq '.Code // 0')
            COMPLEXITY=$(echo "$SCC_DATA" | jq '.Complexity // 0')
            LOC_COL=$(loc_color $LOC)
            CX_COL=$(cx_color $COMPLEXITY)
            echo "{\"schemaVersion\":1,\"label\":\"loc\",\"message\":\"$LOC\",\"color\":\"$LOC_COL\"}" > "badges/gglib-tauri-gui_backend-loc.json"
            echo "{\"schemaVersion\":1,\"label\":\"complexity\",\"message\":\"$COMPLEXITY\",\"color\":\"$CX_COL\"}" > "badges/gglib-tauri-gui_backend-complexity.json"
            echo "  gglib-tauri/gui_backend: $LOC loc, $COMPLEXITY complexity"
          fi
          
          # =============================================================================
          # Per-module badges for gglib-hf
          # =============================================================================
          if [ -d "crates/gglib-hf/src/client" ]; then
            SCC_DATA=$(scc "crates/gglib-hf/src/client" --format json 2>/dev/null | jq '[.[] | select(.Name == "Rust")] | .[0] // {Code: 0, Complexity: 0}')
            LOC=$(echo "$SCC_DATA" | jq '.Code // 0')
            COMPLEXITY=$(echo "$SCC_DATA" | jq '.Complexity // 0')
            LOC_COL=$(loc_color $LOC)
            CX_COL=$(cx_color $COMPLEXITY)
            echo "{\"schemaVersion\":1,\"label\":\"loc\",\"message\":\"$LOC\",\"color\":\"$LOC_COL\"}" > "badges/gglib-hf-client-loc.json"
            echo "{\"schemaVersion\":1,\"label\":\"complexity\",\"message\":\"$COMPLEXITY\",\"color\":\"$CX_COL\"}" > "badges/gglib-hf-client-complexity.json"
            echo "  gglib-hf/client: $LOC loc, $COMPLEXITY complexity"
          fi
          
          # =============================================================================
          # Per-file badges for ALL crates (dynamic discovery)
          # =============================================================================
          
          echo "Generating file-level LOC and complexity badges (dynamic discovery)..."
          
          # Helper function to convert file path to badge name
          # Uses the naming convention from the hardcoded badges:
          # - 1 level (file.rs): just "file"
          # - 2 levels (subdir/file.rs): "subdir-file"
          # - 3+ levels (a/b/file.rs): just "b-file" (last 2 components)
          path_to_badge_name() {
            local FILE_PATH=$1
            # Remove src/ prefix and .rs suffix
            local CLEAN=$(echo "$FILE_PATH" | sed 's|^src/||' | sed 's|\.rs$||')
            # Count path components
            local DEPTH=$(echo "$CLEAN" | tr '/' '\n' | wc -l | tr -d ' ')
            
            if [ "$DEPTH" -le 2 ]; then
              # 1-2 levels: use full path with slashes replaced by dashes
              echo "$CLEAN" | sed 's|/|-|g'
            else
              # 3+ levels: use only last 2 components
              echo "$CLEAN" | rev | cut -d'/' -f1-2 | rev | sed 's|/|-|g'
            fi
          }
          
          # Dynamically discover and generate file-level LOC/Complexity for each crate
          for CRATE in gglib-core gglib-db gglib-gguf gglib-hf gglib-download gglib-mcp gglib-proxy gglib-runtime gglib-gui gglib-cli gglib-axum gglib-tauri; do
            if [ -d "crates/$CRATE/src" ]; then
              echo "  Processing $CRATE file-level metrics..."
              
              # Find all .rs files (excluding lib.rs and mod.rs)
              find "crates/$CRATE/src" -name "*.rs" -type f | while read -r FULL_PATH; do
                FILENAME=$(basename "$FULL_PATH")
                
                # Skip lib.rs and mod.rs (they're just re-exports)
                if [[ "$FILENAME" != "lib.rs" ]] && [[ "$FILENAME" != "mod.rs" ]]; then
                  # Extract relative path from src/
                  REL_PATH=$(echo "$FULL_PATH" | sed "s|crates/$CRATE/||")
                  BADGE_SUFFIX=$(path_to_badge_name "$REL_PATH")
                  BADGE_NAME="$CRATE-$BADGE_SUFFIX"
                  
                  # Generate LOC and Complexity using scc
                  SCC_DATA=$(scc "$FULL_PATH" --format json 2>/dev/null | jq '[.[] | select(.Name == "Rust")] | .[0] // {Code: 0, Complexity: 0}')
                  LOC=$(echo "$SCC_DATA" | jq '.Code // 0')
                  COMPLEXITY=$(echo "$SCC_DATA" | jq '.Complexity // 0')
                  LOC_COL=$(loc_color $LOC)
                  CX_COL=$(cx_color $COMPLEXITY)
                  
                  echo "{\"schemaVersion\":1,\"label\":\"loc\",\"message\":\"$LOC\",\"color\":\"$LOC_COL\"}" > "badges/$BADGE_NAME-loc.json"
                  echo "{\"schemaVersion\":1,\"label\":\"complexity\",\"message\":\"$COMPLEXITY\",\"color\":\"$CX_COL\"}" > "badges/$BADGE_NAME-complexity.json"
                fi
              done
              
              # Also generate directory aggregate badges for subdirectories with multiple files
              find "crates/$CRATE/src" -type d -mindepth 1 | while read -r DIR_PATH; do
                # Only generate aggregate if directory has .rs files (not just mod.rs)
                RS_COUNT=$(find "$DIR_PATH" -maxdepth 1 -name "*.rs" ! -name "mod.rs" -type f 2>/dev/null | wc -l | tr -d ' ')
                if [ "$RS_COUNT" -gt 0 ]; then
                  REL_PATH=$(echo "$DIR_PATH" | sed "s|crates/$CRATE/||")
                  # For directories, use simplified naming: just the last directory component
                  # This matches the convention used by generate_module_tables.sh
                  DIR_NAME=$(basename "$DIR_PATH")
                  BADGE_NAME="$CRATE-$DIR_NAME"
                  
                  SCC_DATA=$(scc "$DIR_PATH" --format json 2>/dev/null | jq '[.[] | select(.Name == "Rust")] | .[0] // {Code: 0, Complexity: 0}')
                  LOC=$(echo "$SCC_DATA" | jq '.Code // 0')
                  COMPLEXITY=$(echo "$SCC_DATA" | jq '.Complexity // 0')
                  LOC_COL=$(loc_color $LOC)
                  CX_COL=$(cx_color $COMPLEXITY)
                  
                  echo "{\"schemaVersion\":1,\"label\":\"loc\",\"message\":\"$LOC\",\"color\":\"$LOC_COL\"}" > "badges/$BADGE_NAME-loc.json"
                  echo "{\"schemaVersion\":1,\"label\":\"complexity\",\"message\":\"$COMPLEXITY\",\"color\":\"$CX_COL\"}" > "badges/$BADGE_NAME-complexity.json"
                fi
              done
            fi
          done
          
          echo "Generated file-level LOC and complexity badges"
          
          # =============================================================================
          # TypeScript module badges
          # =============================================================================
          for MODULE in components hooks contexts services utils commands; do
            if [ -d "src/$MODULE" ]; then
              TS_DATA=$(scc "src/$MODULE" --include-ext ts,tsx --format json 2>/dev/null)
              TS_LOC=$(echo "$TS_DATA" | jq '[.[] | select(.Name == "TypeScript" or .Name == "TypeScript JSX")] | map(.Code) | add // 0')
              TS_COMPLEXITY=$(echo "$TS_DATA" | jq '[.[] | select(.Name == "TypeScript" or .Name == "TypeScript JSX")] | map(.Complexity) | add // 0')
              
              if [ "$TS_LOC" -lt 500 ]; then TS_LOC_COL="brightgreen";
              elif [ "$TS_LOC" -lt 1000 ]; then TS_LOC_COL="green";
              elif [ "$TS_LOC" -lt 2000 ]; then TS_LOC_COL="yellowgreen";
              else TS_LOC_COL="yellow"; fi
              
              if [ "$TS_COMPLEXITY" -lt 20 ]; then TS_CX_COL="brightgreen";
              elif [ "$TS_COMPLEXITY" -lt 50 ]; then TS_CX_COL="green";
              elif [ "$TS_COMPLEXITY" -lt 100 ]; then TS_CX_COL="yellowgreen";
              else TS_CX_COL="yellow"; fi
              
              echo "{\"schemaVersion\":1,\"label\":\"loc\",\"message\":\"$TS_LOC\",\"color\":\"$TS_LOC_COL\"}" > "badges/ts-$MODULE-loc.json"
              echo "{\"schemaVersion\":1,\"label\":\"complexity\",\"message\":\"$TS_COMPLEXITY\",\"color\":\"$TS_CX_COL\"}" > "badges/ts-$MODULE-complexity.json"
              echo "  src/$MODULE: $TS_LOC loc, $TS_COMPLEXITY complexity"
            fi
          done
          
          # TypeScript aggregate LOC and complexity
          TS_DATA=$(scc src --include-ext ts,tsx --format json 2>/dev/null)
          TS_LOC=$(echo "$TS_DATA" | jq '[.[] | select(.Name == "TypeScript" or .Name == "TypeScript JSX")] | map(.Code) | add // 0')
          TS_COMPLEXITY=$(echo "$TS_DATA" | jq '[.[] | select(.Name == "TypeScript" or .Name == "TypeScript JSX")] | map(.Complexity) | add // 0')
          
          if [ "$TS_LOC" -lt 2000 ]; then TS_LOC_COL="brightgreen";
          elif [ "$TS_LOC" -lt 5000 ]; then TS_LOC_COL="green";
          elif [ "$TS_LOC" -lt 10000 ]; then TS_LOC_COL="yellowgreen";
          else TS_LOC_COL="yellow"; fi
          
          if [ "$TS_COMPLEXITY" -lt 50 ]; then TS_CX_COL="brightgreen";
          elif [ "$TS_COMPLEXITY" -lt 150 ]; then TS_CX_COL="green";
          elif [ "$TS_COMPLEXITY" -lt 300 ]; then TS_CX_COL="yellowgreen";
          else TS_CX_COL="yellow"; fi
          
          echo "{\"schemaVersion\":1,\"label\":\"loc\",\"message\":\"$TS_LOC\",\"color\":\"$TS_LOC_COL\"}" > badges/ts-loc.json
          echo "{\"schemaVersion\":1,\"label\":\"complexity\",\"message\":\"$TS_COMPLEXITY\",\"color\":\"$TS_CX_COL\"}" > badges/ts-complexity.json
          echo "Web UI: $TS_LOC loc, $TS_COMPLEXITY complexity"
          
          echo "Generated release badges:"
          ls -la badges/

      - name: Deploy to badges branch
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./badges
          publish_branch: badges
          keep_files: true
          user_name: 'github-actions[bot]'
          user_email: 'github-actions[bot]@users.noreply.github.com'
          commit_message: 'Update release badges [skip ci] ${{ github.event.workflow_run.head_sha }}'
