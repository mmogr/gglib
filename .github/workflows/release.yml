name: Release
on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]
    branches: [main]
  workflow_dispatch:
    inputs:
      test_run:
        description: 'Test run (skip actual release)'
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  issues: write
  pull-requests: write
  pages: write
  id-token: write
  deployments: write

jobs:
  check-version:
    name: Check Version Change
    runs-on: ubuntu-latest
    if: ${{ (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') || github.event_name == 'workflow_dispatch' }}
    outputs:
      version-changed: ${{ steps.version-check.outputs.changed }}
      new-version: ${{ steps.version-check.outputs.version }}
      tag-exists: ${{ steps.tag-check.outputs.exists }}
      is-test-version: ${{ steps.version-check.outputs.is-test }}
      is-prerelease: ${{ steps.version-check.outputs.is-prerelease }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get current version
        id: version-check
        run: |
          CURRENT_VERSION=$(grep '^version = ' Cargo.toml | sed -E 's/version = "(.*)"/\1/')
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          
          # Check if version contains -test suffix
          if [[ "$CURRENT_VERSION" == *"-test"* ]]; then
            echo "is-test=true" >> $GITHUB_OUTPUT
            echo "::notice::ðŸ§ª Test version detected: v$CURRENT_VERSION - Will run in test mode"
          else
            echo "is-test=false" >> $GITHUB_OUTPUT
          fi
          
          # Check if version is a prerelease (-alpha or -beta suffix)
          if [[ "$CURRENT_VERSION" == *"-alpha"* ]] || [[ "$CURRENT_VERSION" == *"-beta"* ]]; then
            echo "is-prerelease=true" >> $GITHUB_OUTPUT
            echo "::notice::ðŸ“¦ Prerelease version detected: v$CURRENT_VERSION"
          else
            echo "is-prerelease=false" >> $GITHUB_OUTPUT
          fi
          
          # Check if this version exists in git tags
          if git tag -l | grep -q "^v${CURRENT_VERSION}$"; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "Version v$CURRENT_VERSION already exists"
          else
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "New version detected: v$CURRENT_VERSION"
          fi

      - name: Check if tag exists
        id: tag-check
        run: |
          if git tag -l | grep -q "^v${{ steps.version-check.outputs.version }}$"; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: check-version
    if: github.event_name == 'push' && needs.check-version.outputs.version-changed == 'true' && needs.check-version.outputs.is-test-version != 'true' && inputs.test_run != true
    outputs:
      version: ${{ needs.check-version.outputs.new-version }}
    steps:
      - name: ðŸ§ª Test Mode Banner
        if: github.event_name == 'workflow_dispatch' && inputs.test_run == true
        run: |
          echo "::warning::ðŸ§ª TEST MODE - No release will be created"
          echo "This is a test run. Skipping actual release creation."

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Create and push tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag v${{ needs.check-version.outputs.new-version }}
          git push origin v${{ needs.check-version.outputs.new-version }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.check-version.outputs.new-version }}
          name: Release v${{ needs.check-version.outputs.new-version }}
          draft: false
          prerelease: ${{ needs.check-version.outputs.is-prerelease == 'true' }}
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  deploy-docs:
    name: Deploy Documentation
    runs-on: ubuntu-latest
    needs: [check-version, create-release]
    if: github.event_name == 'push' && needs.check-version.outputs.version-changed == 'true' && needs.check-version.outputs.is-test-version != 'true' && needs.check-version.outputs.is-prerelease != 'true' && inputs.test_run != true
    # Allow one concurrent deployment
    concurrency:
      group: "pages"
      cancel-in-progress: true
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Always checkout main branch for docs, even when triggered by release tag
          ref: main

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Setup Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: "docs-ubuntu"
          cache-on-failure: true

      - name: Cache node_modules
        uses: actions/cache@v3
        with:
          path: node_modules
          key: ubuntu-${{ runner.arch }}-node-${{ hashFiles('package.json') }}

      - name: Cache Web UI
        id: webui-cache
        uses: actions/cache@v3
        with:
          path: web_ui
          key: ubuntu-${{ runner.arch }}-webui-${{ hashFiles('src/**/*.{ts,tsx}', 'index.html', 'vite.config.ts', 'package.json') }}

      - name: Setup Node.js
        if: steps.webui-cache.outputs.cache-hit != 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Build Web UI
        if: steps.webui-cache.outputs.cache-hit != 'true'
        run: |
          npm install
          npm run build

      - name: Build documentation
        run: cargo doc --workspace --no-deps --document-private-items --exclude gglib-tauri

      - name: Create index.html redirect
        run: |
          cat > target/doc/index.html << 'EOF'
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <title>gglib Documentation</title>
            <meta http-equiv="refresh" content="0; url=gglib/index.html">
            <link rel="canonical" href="gglib/index.html">
            <style>
              body { 
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
                text-align: center;
                padding: 50px;
                background: #f5f5f5;
              }
              .container {
                max-width: 600px;
                margin: 0 auto;
                background: white;
                padding: 40px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
              }
              a { color: #0366d6; text-decoration: none; }
              a:hover { text-decoration: underline; }
            </style>
          </head>
          <body>
            <div class="container">
              <h1>ðŸ¦€ gglib Documentation</h1>
              <p>Redirecting to the <a href="gglib/index.html">gglib documentation</a>...</p>
              <p><small>If you're not redirected automatically, <a href="gglib/index.html">click here</a>.</small></p>
            </div>
          </body>
          </html>
          EOF

      - name: Setup Pages
        uses: actions/configure-pages@v5

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: './target/doc'

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

      - name: Update deployment status
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'github-pages',
              description: 'Docs deployment via GitHub Actions',
              auto_merge: false,
              required_contexts: []
            });
            
            const status = '${{ steps.deployment.outcome }}' === 'success' ? 'success' : 'failure';
            
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: status,
              description: status === 'success' ? 'Documentation deployed successfully' : 'Documentation deployment failed',
              environment_url: status === 'success' ? 'https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}' : undefined
            });

  build:
    name: Build ${{ matrix.target }}
    runs-on: ${{ matrix.os }}
    needs: [check-version]
    if: github.event_name == 'push' && needs.check-version.outputs.version-changed == 'true'
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-latest
          - target: aarch64-apple-darwin
            os: macos-14
          - target: x86_64-pc-windows-msvc
            os: windows-latest

    steps:
      - name: ðŸ§ª Test Mode Banner
        if: needs.check-version.outputs.is-test-version == 'true' || inputs.test_run == true
        run: |
          echo "::notice::ðŸ§ª TEST MODE - Builds will run but no release will be created"

      - name: Free Disk Space (Ubuntu)
        if: matrix.os == 'ubuntu-latest'
        uses: jlumbroso/free-disk-space@main
        with:
          tool-cache: false
          android: true
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: true
          swap-storage: true

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.91.0
          targets: ${{ matrix.target }}

      - name: Setup Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: "release-${{ matrix.target }}"
          cache-on-failure: true

      - name: Cache node_modules
        uses: actions/cache@v3
        with:
          path: node_modules
          key: ${{ matrix.target }}-node-${{ hashFiles('package.json') }}

      - name: Cache Web UI
        id: webui-cache
        uses: actions/cache@v3
        with:
          path: web_ui
          key: ${{ matrix.target }}-webui-${{ hashFiles('src/**/*.{ts,tsx}', 'index.html', 'vite.config.ts', 'package.json') }}

      - name: Setup Node.js
        if: steps.webui-cache.outputs.cache-hit != 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Build Web UI
        if: steps.webui-cache.outputs.cache-hit != 'true'
        run: |
          npm install
          npm run build

      - name: Build binary
        run: cargo build --release --target ${{ matrix.target }} -p gglib-cli

      - name: Package binary (Unix)
        if: matrix.os != 'windows-latest'
        run: |
          mkdir -p package
          cp target/${{ matrix.target }}/release/gglib package/
          cp -r web_ui package/
          cd package
          tar czf ../gglib-${{ needs.check-version.outputs.new-version }}-${{ matrix.target }}.tar.gz gglib web_ui
          cd ..

      - name: Package binary (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          mkdir package
          copy target\${{ matrix.target }}\release\gglib.exe package\
          xcopy web_ui package\web_ui\ /E /I /Y
          cd package
          7z a ..\gglib-${{ needs.check-version.outputs.new-version }}-${{ matrix.target }}.zip gglib.exe web_ui
          cd ..

      - name: Upload binary to release (Unix)
        if: matrix.os != 'windows-latest' && needs.check-version.outputs.is-test-version != 'true' && inputs.test_run != true
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.check-version.outputs.new-version }}
          files: gglib-${{ needs.check-version.outputs.new-version }}-${{ matrix.target }}.tar.gz
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload binary to release (Windows)
        if: matrix.os == 'windows-latest' && needs.check-version.outputs.is-test-version != 'true' && inputs.test_run != true
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.check-version.outputs.new-version }}
          files: gglib-${{ needs.check-version.outputs.new-version }}-${{ matrix.target }}.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-gui:
    name: Build GUI ${{ matrix.target }}
    runs-on: ${{ matrix.os }}
    needs: [check-version]
    if: github.event_name == 'push' && needs.check-version.outputs.version-changed == 'true'
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-latest
          - target: aarch64-apple-darwin
            os: macos-14
          - target: x86_64-pc-windows-msvc
            os: windows-latest

    steps:
      - name: ðŸ§ª Test Mode Banner
        if: needs.check-version.outputs.is-test-version == 'true' || inputs.test_run == true
        run: |
          echo "::notice::ðŸ§ª TEST MODE - Builds will run but no release will be created"

      - name: Free Disk Space (Ubuntu)
        if: matrix.os == 'ubuntu-latest'
        uses: jlumbroso/free-disk-space@main
        with:
          tool-cache: false
          android: true
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: true
          swap-storage: true

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.91.0
          targets: ${{ matrix.target }}

      - name: Setup Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: "gui-${{ matrix.target }}"
          cache-on-failure: true
          workspaces: src-tauri

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install frontend dependencies (Unix)
        if: matrix.os != 'windows-latest'
        run: |
          rm -rf node_modules package-lock.json
          npm install

      - name: Install frontend dependencies (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          if (Test-Path node_modules) { Remove-Item -Recurse -Force node_modules }
          if (Test-Path package-lock.json) { Remove-Item -Force package-lock.json }
          npm install
        shell: pwsh

      - name: Install system dependencies (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            patchelf \
            libgtk-3-dev \
            libssl-dev \
            pkg-config

      - name: Build Tauri app
        run: |
          echo "Building Tauri app for ${{ matrix.target }}"
          if [ "${{ matrix.os }}" == "windows-latest" ]; then
            npm run tauri:build -- --target ${{ matrix.target }} --bundles nsis
          else
            npm run tauri:build -- --target ${{ matrix.target }}
          fi
        shell: bash
        
      - name: Debug build output (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          Write-Output "=== BUILD - Checking output structure ==="
          Write-Output "Contents of src-tauri/target:"
          if (Test-Path src-tauri/target/) {
            Get-ChildItem -Force src-tauri/target/
          } else {
            Write-Output "No target directory found"
          }
          Write-Output "Contents of src-tauri/target/release:"
          if (Test-Path src-tauri/target/release/) {
            Get-ChildItem -Force src-tauri/target/release/
          } else {
            Write-Output "No release directory found"
          }
          Write-Output "Contents of src-tauri/target/release/bundle:"
          if (Test-Path src-tauri/target/release/bundle/) {
            Get-ChildItem -Force src-tauri/target/release/bundle/
          } else {
            Write-Output "No bundle directory found"
          }
          Write-Output "Searching for all executables:"
          if (Test-Path src-tauri/target/) {
            Get-ChildItem -Recurse -Name "gglib-app*" src-tauri/target/
          } else {
            Write-Output "No gglib-app executables found"
          }
        shell: pwsh

      - name: Debug build output (Unix)
        if: matrix.os != 'windows-latest'
        run: |
          echo "=== BUILD - Checking output structure ==="
          echo "Contents of src-tauri/target:"
          if [ -d "src-tauri/target/" ]; then
            ls -la src-tauri/target/
          else
            echo "No target directory found"
          fi
          echo "Contents of src-tauri/target/release:"
          if [ -d "src-tauri/target/release/" ]; then
            ls -la src-tauri/target/release/
          else
            echo "No release directory found"
          fi
          echo "Contents of src-tauri/target/release/bundle:"
          if [ -d "src-tauri/target/release/bundle/" ]; then
            ls -la src-tauri/target/release/bundle/
          else
            echo "No bundle directory found"
          fi
          echo "Searching for all .app bundles:"
          find src-tauri/target -name "*.app" -type d 2>/dev/null || echo "No .app bundles found"
          echo "Searching for all executables:"
          find src-tauri/target -name "gglib-app*" -type f 2>/dev/null || echo "No gglib-app executables found"

      - name: Prepare GUI binary for packaging (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          mkdir -p gui-release
          cp src-tauri/target/${{ matrix.target }}/release/gglib-app gui-release/
          chmod +x gui-release/gglib-app

      - name: Prepare GUI binary for packaging (macOS)
        if: startsWith(matrix.os, 'macos')
        run: |
          mkdir -p gui-release
          
          echo "Checking build output structure..."
          echo "Contents of src-tauri/target/${{ matrix.target }}/release:"
          if [ -d "src-tauri/target/${{ matrix.target }}/release/" ]; then
            ls -la "src-tauri/target/${{ matrix.target }}/release/"
          else
            echo "No target-specific release directory found"
          fi
          
          # First check for the bare binary (always created)
          if [ -f "src-tauri/target/${{ matrix.target }}/release/gglib-app" ]; then
            echo "Found bare binary in target-specific directory, copying..."
            cp "src-tauri/target/${{ matrix.target }}/release/gglib-app" gui-release/
            chmod +x gui-release/gglib-app
          else
            echo "ERROR: Bare binary not found! src-tauri/target/${{ matrix.target }}/release/gglib-app does not exist."
            exit 1
          fi
          
          # Try to copy the .app bundle if it exists (only created for native builds, not cross-compilation)
          if [ -d "src-tauri/target/${{ matrix.target }}/release/bundle/macos/GGLib GUI.app" ]; then
            echo "Found .app bundle in target-specific directory, copying..."
            cp -r "src-tauri/target/${{ matrix.target }}/release/bundle/macos/GGLib GUI.app" gui-release/
            
            # Copy the install script and README for macOS users
            echo "Copying macOS install script and README..."
            cp scripts/macos-install.command gui-release/
            cp scripts/MACOS-README.txt gui-release/
            chmod +x gui-release/macos-install.command
          else
            echo "Note: No .app bundle found (expected for cross-compilation). Using bare binary only."
          fi

      - name: Prepare GUI binary for packaging (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          mkdir gui-release
          copy src-tauri\target\${{ matrix.target }}\release\gglib-app.exe gui-release\
          # Also copy the MSI installer if it was built
          if (Test-Path "src-tauri\target\${{ matrix.target }}\release\bundle\msi\*.msi") {
            copy src-tauri\target\${{ matrix.target }}\release\bundle\msi\*.msi gui-release\
          }

      - name: Package GUI binary (Unix)
        if: startsWith(matrix.os, 'ubuntu') || startsWith(matrix.os, 'macos')
        run: |
          cd gui-release
          tar czf ../gglib-gui-${{ needs.check-version.outputs.new-version }}-${{ matrix.target }}.tar.gz *
          cd ..

      - name: Package GUI binary (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          cd gui-release
          7z a ..\gglib-gui-${{ needs.check-version.outputs.new-version }}-${{ matrix.target }}.zip *
          cd ..

      - name: Upload GUI binary to release (Unix)
        if: (startsWith(matrix.os, 'ubuntu') || startsWith(matrix.os, 'macos')) && needs.check-version.outputs.is-test-version != 'true' && inputs.test_run != true
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.check-version.outputs.new-version }}
          files: gglib-gui-${{ needs.check-version.outputs.new-version }}-${{ matrix.target }}.tar.gz
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload GUI binary to release (Windows)
        if: matrix.os == 'windows-latest' && needs.check-version.outputs.is-test-version != 'true' && inputs.test_run != true
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.check-version.outputs.new-version }}
          files: gglib-gui-${{ needs.check-version.outputs.new-version }}-${{ matrix.target }}.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}